/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <stdint.h>
typedef volatile unsigned int vuint32_t;

//RCC register
#define RCC_BASE 		0x40021000
#define RCC_APB2ENR 	*(volatile uint32_t *)(RCC_BASE + 0x18)
#define RCC_IOPEN		(1 << 2)
//GPIO register
#define GPIOA_BASE 		0x40010800
#define GPIOA_CRL 		*(volatile uint32_t *)(GPIOA_BASE + 0x00)
#define GPIOA_CRH 		*(volatile uint32_t *)(GPIOA_BASE + 0x04)
#define GPIOA_ODR 		*(volatile uint32_t *)(GPIOA_BASE + 0x0C)
#define GPIOA_IDR 		*(volatile uint32_t *)(GPIOA_BASE + 0x08)


#define GPIOB_BASE 		0x40010C00
#define GPIOB_CRL 		*(volatile uint32_t *)(GPIOB_BASE + 0x00)
#define GPIOB_CRH 		*(volatile uint32_t *)(GPIOB_BASE + 0x04)
#define GPIOB_ODR 		*(volatile uint32_t *)(GPIOB_BASE + 0x0C)
#define GPIOB_IDR 		*(volatile uint32_t *)(GPIOB_BASE + 0x08)

void Clock_Init()
{
	//	enable clock GPIOA
	RCC_APB2ENR |= RCC_IOPEN;
	//	enable clock GPIOB
	RCC_APB2ENR |= (1<<3);

}
void GPIO_Init()
{
	GPIOA_CRL = 0;
	GPIOA_CRH = 0;
	GPIOB_CRL = 0;
	GPIOB_CRH = 0;
	//	00: Analog mode
	//	01: Floating input (reset state)
	//	10: Input with pull-up / pull-down
	//	11: Reserved
	//	Pin 1 port A input
	//	00: Input mode (reset state)
	//	01: Floating input (reset state)
	GPIOA_CRL |= (0b0100 << 4);

	//	Pin 13 port A input
	//	00: Input mode (reset state)
	//	01: Floating input (reset state)
	GPIOA_CRH |= (0b0100 <<20);

	//	Pin 1 Port B Push-Pull output
	//	01: Output mode, max speed 10 MHz.
	//	00: General purpose output push-pull
	GPIOB_CRL |= (0b0001 << 4);

	//	Pin 13 port B Push-Pull 01: Output mode, max speed 10 MHz. output
	//	01: Output mode, max speed 10 MHz.
	//	00: General purpose output push-pull
	GPIOB_CRH |= (0b0001 <<20);


}
void wait(vuint32_t time)
{

	vuint32_t i,j;
	for (i =0; i<time;i++)
	{
		for (j=0 ; j<255;j++)
		{

		}
	}

}

int main(void)
{
	Clock_Init();
	GPIO_Init();

	while(1)
	{
		if(((GPIOA_IDR & (1<<1)) >> 1) ==0)
		{
			GPIOB_ODR ^= (1<<1);
			//			single press
			while(((GPIOA_IDR & (1<<1)) << 1) ==0);
		}
		if(((GPIOA_IDR & (1<<13))>> 13) == 1)
		{
			//			multi press
			GPIOB_ODR ^= (1<<13);
		}
		wait(1);

	}
}



