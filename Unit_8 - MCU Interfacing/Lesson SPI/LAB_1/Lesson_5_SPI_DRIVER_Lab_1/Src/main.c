/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */



/*******************************************************************************
Lab1: configure UART and SPI
 * send and receive by UART and send the same data to SPI
 ******************************************************************************/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif




#include "STM32F103xx6.h"
#include "STM32F103C6_EXTI_DRIVER.h"
#include "STM32F103C6_GPIO_DRIVER.h"
#include "STM32F103C6_RCC_DRIVER.h"
#include "STM32F103C6_USART_DRIVER.h"
#include "STM32F103C6_SPI_DRIVER.h"





void Clock_Init()
{
	//open clock of AFIO
	RCC_AFIO_CLK_EN();

	//open clock of GPIOA
	RCC_GPIOA_CLK_EN();

	//open clock of GPIOB
	RCC_GPIOB_CLK_EN();
}

void UART_IRQ_CallBack(void);

#define MCU_Act_as_Master
//#define MCU_Act_as_Slave

uint8_t ch;


int main(void)
{
	Clock_Init();

	//======================UART Init===================================
	/*
	 * Tx  --> PA9
	 * Rx  --> PA10
	 * CTS --> PA11
	 * RTS --> PA12
	 */
	UART_Configuration_t UART_CFG;
	UART_CFG.UART_MODE = UART_MODE_Tx_Rx;
	UART_CFG.UART_Payload_length = UART_Payload_length_8B;
	UART_CFG.UART_Num_Stop_Bits = UART_Num_Stop_Bits_one_bit;
	UART_CFG.UART_Parity = UART_Parity_NONE;
	UART_CFG.UART_BaudRate = UART_BaudRate_115200;
	UART_CFG.UART_HW_FLOW_CTL = UART_HW_FLOW_CTL_NONE;
	UART_CFG.UART_IRQ_Enable = UART_IRQ_Enable_RXNE;
	UART_CFG.UART_PF_IRQ_CallBack = UART_IRQ_CallBack;

	MCAL_UART_Init(USART1, &UART_CFG);
	MCAL_UART_GPIO_Set_Pins(USART1);

	//======================SPI Init===================================
	/*
	 * SCLK --> PA5
	 * MOSI --> PA7
	 * MISO --> PA6
	 * NSS  --> PA4
	 */
	SPI_Configuration_t SPI1_CFG;
	/* Common Configuration */
	SPI1_CFG.SPI_Clock_Phase = SPI_Clock_Phase_2nd_Edge;
	SPI1_CFG.SPI_Clock_Polarity = SPI_Clock_Polarity_high_idle;
	SPI1_CFG.SPI_Data_Size = SPI_Data_Size_8B;
	SPI1_CFG.SPI_Frame_Format = SPI_Frame_Format_MSB_First;
	SPI1_CFG.SPI_BuadRate_PreScalar = SPI_BaudRate_PreScalar_Divide_8;
	SPI1_CFG.SPI_Communication_Mode = SPI_Communication_Mode_2Line_FD;

	/* Master Configuration */
#ifdef MCU_Act_as_Master
	SPI1_CFG.SPI_Device_Mode = SPI_Device_Mode_Master;
	SPI1_CFG.SPI_NSS = SPI_NSS_Software_Internal_slave_select_Enable;
	SPI1_CFG.SPI_IRQ_Enable = SPI_IRQ_Enable_NONE;
	SPI1_CFG.PF_IRQ_CallBack = NULL;

	//Configure SS on PortA pin4
	GPIO_PIN_Configuration_t PinCFG;
	PinCFG.GPIO_PinNumber = GPIO_PIN_4;
	PinCFG.GPIO_PinMODE = GPIO_MODE_OUTPUT_PP;
	PinCFG.GPIO_PinSPEED = GPIO_SPEED_10MHz;
	MCAL_GPIO_Init(GPIOA, &PinCFG);

	//set SS in idle mode
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
#endif

	MCAL_SPI_Init(SPI1, &SPI1_CFG);
	MCAL_GPIO_SPI_Set_Pins(SPI1);


	/* Loop forever */
	while(1)
	{

	}
}

void UART_IRQ_CallBack(void)
{

#ifdef MCU_Act_as_Master
	MCAL_UART_ReceiveData(USART1, &ch, disable);
	MCAL_UART_SendData(USART1, &ch, enable);

	//send data to SPI
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
	MCAL_SPI_Tx_Rx(SPI1, &ch, Polling_Enable);
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
#endif
}




